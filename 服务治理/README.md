
* [服务治理](#服务治理)
* [微服务治理平台的基本功能](#微服务治理平台的基本功能)
  * [服务管理功能---注册中心](#服务管理)
    * [服务上下线]()
    * [节点添加/删除]()
    * [服务查询]()
    * [服务节点查询]()
  * [服务治理功能---配置中心](#服务治理)
    * [限流]()
    * [降级]()
    * [切流量]()
  * [服务监控功能](#服务监控)  
  * [问题定位功能](#问题定位)
  * [⽇志查询功能](#⽇志查询)
  * [服务运维功能](#服务运维)
* [服务治理问题的种类](#问题的种类)
  * [服务调用问题](#服务调用问题)
    * [服务调用问题的解决方案](#服务调用问题的解决方案)
      * [⼼跳开关保护机制方案](#⼼跳开关保护机制)
      * [服务节点摘除保护机制方案](#服务节点摘除保护机制)
      * [静态注册中⼼方案](#静态注册中⼼)
  * [负载均衡问题](#负载均衡)
    * [随机算法](#随机算法)
    * [轮询算法](#轮询算法)
    * [加权轮询算法](#加权轮询算法)
    * [最少活跃连接算法](#最少活跃连接算法)
    * [⼀致性hash算法](#⼀致性hash算法)
    * [⾃适应最优选择算法](#⾃适应最优选择算法)
    * []()
  * [服务路由问题](#服务路由)
    * [服务路由的规则](#服务路由的规则)
    * [服务路由的应⽤场景](#服务路由的应⽤场景)
    * [服务路由配置⽅式](#服务路由配置⽅式)
  * [服务容错问题](#服务容错)
---

# 服务治理


    单体应⽤改造为微服务架构后，服务调⽤从本地调⽤变成了远程⽅法调⽤后，⾯临的各种不确定因素变多了，⼀⽅⾯你需要能够监控各个服务的实时运⾏状态、服
    务调⽤的链路和拓扑图；另⼀⽅⾯你需要在出现故障时，能够快速定位故障的原因并可以通过诸如降级、限流、切流量、扩容等⼿段快速⼲预⽌损。这个时候就需
    要我今天要讲的微服务治理平台了
    
    服务监控能够发现问题，服务追踪能够定位问题所在，⽽解决问题就得靠服务治理了。服务治理就是通过⼀系列的⼿段来保证 在各种意外情况下，服务调⽤仍然能
    够正常进⾏
    
    在⽣产环境中，你应该经常会遇到下⾯⼏种状况。
    
    单机故障。通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然⽽集群的规模越⼤，越是容易遇到单机故障，在机器规模超过⼀百台以
    上时，靠传统的⼈⾁运维显然难以应对。⽽服务治理可以通过⼀定的策略，⾃动摘除故障节点，不需要⼈为⼲预，就能保证单机故障不会影响业务。
    
    单IDC故障。你应该经常听说某某App，因为施⼯挖断光缆导致⼤批量⽤户⽆法使⽤的严重故障。⽽服务治理可以通过⾃动切换故障IDC的流量到其他正常IDC，可以
    避免因为单IDC故障引起的⼤批量业务受影响。
    
    依赖服务不可⽤。⽐如你的服务依赖依赖了另⼀个服务，当另⼀个服务出现问题时，会拖慢甚⾄拖垮你的服务。⽽服务治理可以通过熔断，在依赖服务异常的情况下，
    ⼀段时期内停⽌发起调⽤⽽直接返回。这样⼀⽅⾯保证了服务消费者能够不被拖垮，另⼀⽅⾯也给服务提供者减少压⼒，使其能够尽快恢复。
    
    ⾃动扩缩容，可以⽤来解决服务的容量问题

# 微服务治理平台的基本功能

<a href="https://ibb.co/Wy2xGk1"><img src="https://i.ibb.co/2tknWvB/23-9.png" alt="23-9" border="0"></a><br /><a target='_blank' href='https://imgbb.com/'>upload</a><br />

## 服务管理
    
    通过微服务治理平台，可以调⽤注册中⼼提供的各种管理接⼝来实现服务的管理
    
    服务上下线。当上线⼀个新服务的时候，可以通过调⽤注册中⼼的服务添加接⼝，新添加⼀个服务，同样要下线⼀个已有服务的时候，也可以通过调⽤注册中⼼的
    服务注销接⼝，删除⼀个服务。
    
    节点添加/删除。当需要给服务新添加节点时候，可以通过调⽤注册中⼼的节点注册接⼝，来给服务新增加⼀个节点。⽽当有故障节点出现或者想临时下线⼀些节
    点时，可以通过调⽤注册中⼼的节点反注册接⼝，来删除节点。
    
    服务查询。这个操作会调⽤注册中⼼的服务查询接⼝，可以查询当前注册中⼼⾥共注册了多少个服务，每个服务的详细信息。
    
    服务节点查询。这个操作会调⽤注册中⼼的节点查询接⼝，来查询某个服务下⼀共有多少个节点

## 服务治理

   通过微服务治理平台，可以调⽤配置中⼼提供的接⼝，动态地修改各种配置来实现服务的治理,常⽤的服务治理⼿段包括以下⼏种：
   
    限流:
   
    ⼀般是在系统出现故障的时候，⽐如像微博因为热点突发事件的发⽣，可能会在短时间内流量翻⼏倍，超出系统的最⼤容量。这个时候就需要调⽤配置中⼼的接
    ⼝，去修改⾮核⼼服务的限流阈值，从⽽减少⾮核⼼服务的调⽤，给核⼼服务留出充⾜的冗余度。
    
    降级:
    
    跟限流⼀样，降级也是系统出现故障时的应对⽅案。要么是因为突发流量的到来，导致系统的容量不⾜，这时可以通过降级⼀些⾮核⼼业务，来增加系统的
    冗余度；要么是因为某些依赖服务的问题，导致系统被拖慢，这时可以降级对依赖服务的调⽤，避免被拖死。
    
    切流量:
    
    通常为了服务的异地容灾考虑，服务部署在不⽌⼀个IDC内。当某个IDC因为电缆被挖断、机房断电等不可抗⼒时，需要把故障IDC的流量切换到其他正
    常IDC，这时候可以调⽤配置中⼼的接⼝，向所有订阅了故障IDC服务的消费者下发指令，将流量统统切换到其他正常IDC，从⽽避免服务消费者受影响。
   
## 服务监控

    微服务治理平台⼀般包括两个层⾯的监控。⼀个是整体监控，⽐如服务依赖拓扑图，将整个系统内服务间的调⽤关系和依赖关系进⾏可视化的展示；⼀个是具体
    服务监控，⽐如服务的QPS、AvgTime、P999等监控指标。其中整体监控可以使⽤服务追踪系统提供的服务依赖拓扑图，⽽具体服务监控则可以通过Grafana等
    监控系统UI来展示
   
## 问题定位

    微服务治理平台实现问题定位，可以从两个⽅⾯来进⾏。⼀个是宏观层⾯，即通过服务监控来发觉异常，⽐如某个服务的平均耗时异常导致调⽤失败；⼀个是微观
    层⾯，即通过服务追踪来具体定位⼀次⽤户请求失败具体是因为服务调⽤全链路的哪⼀层导致的

## ⽇志查询

    微服务治理平台可以通过接⼊类似ELK的⽇志系统，能够实时地查询某个⽤户的请求的详细信息或者某⼀类⽤户请求的数据统计。
    
## 服务运维

   发布部署。当服务有功能变更，需要重新发布部署的时候，可以调⽤容器管理平台分批按⽐例进⾏重新部署，然后发布到线上。

   扩缩容。在流量增加或者减少的时候，需要相应地增加或者缩减服务在线上部署的实例，这时候可以调⽤容器管理平台来扩容或者缩容。

# 问题的种类
 
## 服务调用问题

    单体应⽤改造为微服务架构后，服务调⽤由本地调⽤变成远程调⽤，服务消费者A需要通过注册中⼼去查询服务提供者B的地址，然后发起调⽤，这个看似简单的
    过程就可能会遇到下⾯⼏种情况
    
    注册中⼼宕机；
    服务提供者B有节点宕机；
    服务消费者A和注册中⼼之间的⽹络不通；
    服务提供者B和注册中⼼之间的⽹络不通；
    服务消费者A和服务提供者B之间的⽹络不通；
    服务提供者B有些节点性能变慢；
    服务提供者B短时间内出现问题。

    可⻅，⼀次服务调⽤，服务提供者、注册中⼼、⽹络这三者都可能会有问题
    
    服务调⽤失败⼀般是由两类原因引起的：
    
    ⼀类是服务提供者⾃身出现问题，如服务器宕机、进程意外退出等；
    
    ⼀类是⽹络问题，如服务提供者、注册中⼼、服务消费者这三者任意两者之间的⽹络出现问题。
    
## 服务调用问题的解决方案

**1. 注册中⼼主动摘除机制**
    
       这种机制要求服务提供者定时的主动向注册中⼼汇报⼼跳，注册中⼼根据服务提供者节点最近⼀次汇报⼼跳的时间与上⼀次汇报⼼跳时间做⽐较，如果超出⼀定
       时间，就认为服务提供者出现问题，继⽽把节点从服务列表中摘除，并把最近的可⽤服务节点列表推送给服务消费者
    
       如何识别服务节点是否存活？
       这种机制在⼤部分情况下都可以⼯作得很好，但是在⽹络频繁抖动时，服务提供者向注册中⼼汇报⼼跳信息可能会失败，如果在规定的时间内，注册中⼼都没有
       收到服务提供者的⼼跳信息，就会把这个节点从可⽤节点列表中移除。更糟糕的是，在服务池拥有上百个节点的的时候，每个节点都可能会被移除，导致注册中
       ⼼可⽤节点的状态⼀直在变化，这个时候应该如何处理呢？
       
  **注册中⼼主动摘除机制的几种解决方案：**
       
  ### 心跳开关保护机制
  
     在⽹络频繁抖动的情况下，注册中⼼中可⽤的节点会不断变化，这时候服务消费者会频繁收到服务提供者节点变更的信息，于是就不断地请求注册中⼼来拉取最新
     的可⽤服务节点信息。当有成百上千个服务消费者，同时请求注册中⼼获取最新的服务提供者的节点信息时，可能会把注册中⼼的带宽给占满，尤其是注册中⼼是
     百兆⽹卡的情况下。所以针对这种情况，需要⼀种保护机制，即使在⽹络频繁抖动的时候，服务消费者也不⾄于同时去请求注册中⼼获取最新的服务节点信息。
     
     我曾经就遇到过这种情况，⼀个可⾏的解决⽅案就是给注册中⼼设置⼀个开关，当开关打开时，即使⽹络频繁抖动，注册中⼼也不会通知所有的服务消费者有服务
     节点信息变更，⽐如只给10%的服务消费者返回变更，这样的话就能将注册中⼼的请求量减少到原来的1/10。当然打开这个开关也是有⼀定代价的，它会导致服务
     消费者感知最新的服务节点信息延迟，原先可能在10s内就能感知到服务提供者节点信息的变更，现在可能会延迟到⼏分钟，所以在⽹络正常的情况下，开关并不
     适合打开；可以作为⼀个紧急措施，在⽹络频繁抖动的时候，才打开这个开关。
       
  ### 服务节点摘除保护机制
  
     服务提供者在进程启动时，会注册服务到注册中⼼，并每隔⼀段时间，汇报⼼跳给注册中⼼，以标识⾃⼰的存活状态。如果隔了⼀段固定时间后，服务提供者仍然
     没有汇报⼼跳给注册中⼼，注册中⼼就会认为该节点已经处于“dead”状态，于是从服务的可⽤节点信息中移除出去。
     
     如果遇到⽹络问题，⼤批服务提供者节点汇报给注册中⼼的⼼跳信息都可能会传达失败，注册中⼼就会把它们都从可⽤节点列表中移除出去，造成剩下的可⽤节点
     难以承受所有的调⽤，引起“雪崩”。但是这种情况下，可能⼤部分服务提供者节点是可⽤的，仅仅因为⽹络原因⽆法汇报⼼跳给注册中⼼就被“⽆情”的摘除了。这
     个时候就需要根据实际业务的情况，设定⼀个阈值⽐例，即使遇到刚才说的这种情况，注册中⼼也不能摘除超过这个阈值⽐例的节点。
     
     这个阈值⽐例可以根据实际业务的冗余度来确定，我通常会把这个⽐例设定在20%，就是说注册中⼼不能摘除超过20%的节点。因为⼤部分情况下，节点的变化不
     会这么频繁，只有在⽹络抖动或者业务明确要下线⼤批量节点的情况下才有可能发⽣。⽽业务明确要下线⼤批量节点的情况是可以预知的，这种情况下可以关闭
     阈值保护；⽽正常情况下，应该打开阈值保护，以防⽌⽹络抖动时，⼤批量可⽤的服务节点被摘除。
  
**⼼跳开关保护机制，是为了防⽌服务提供者节点频繁变更导致的服务消费者同时去注册中⼼获取最新服务节点信息；服务节点摘除保护机制，是为了防⽌服务提供者节点被⼤量摘除引起服务消费者可以调⽤的节点不⾜。可⻅，⽆论是⼼跳开关保护机制还是服务节点摘除保护机制，都是因为注册中⼼⾥的节点信
息是随时可能发⽣变化的，所以也可以把注册中⼼叫作动态注册中⼼。**
  
  ### 静态注册中⼼
  
    前⾯讲过⼼跳机制能保证在服务提供者出现异常时，注册中⼼可以及时把不可⽤的服务提供者从可⽤节点列表中移除出去，正常情况下这是个很好的机制。但是仔
    细思考⼀下，为什么不把这种⼼跳机制直接⽤在服务消费者端呢？因为服务提供者是向服务消费者提供服务的，是否可⽤服务消费者应该⽐注册中⼼更清楚，因此
    可以直接在服务消费者端根据调⽤服务提供者是否成功来判定服务提供者是否可⽤。如果服务消费者调⽤某⼀个服务提供者节点连续失败超过⼀定次数，可以在本地
    内存中将这个节点标记为不可⽤。并且每隔⼀段固定时间，服务消费者都要向标记为不可⽤的节点发起保活探测，如果探测成功了，就将标记为不可⽤的节点再恢复
    为可⽤状态，重新发起调⽤。这样的话，服务提供者节点就不需要向注册中⼼汇报⼼跳信息，注册中⼼中的服务节点信息也不会动态变化，也可以称之为静态注册
    中⼼。从我的实践经历来看，⼀开始采⽤了动态注册中⼼，后来考虑到⽹络的复杂性，⼼跳机制不⼀定是可靠的，⽽后开始改为采⽤服务消费者端的保活机制，事实
    证明这种机制⾜以应对⽹络频繁抖动等复杂的场景。当然静态注册中⼼中的服务节点信息并不是⼀直不变，当在业务上线或者运维⼈⼯增加或者删除服务节点这种
    预先感知的情况下，还是有必要去修改注册中⼼中的服务节点信息。⽐如在业务上线过程中，需要把正在部署的服务节点从注册中⼼中移除，等到服务部署完毕，
    完全可⽤的时候，再加⼊到注册中⼼。还有就是在业务新增或者下线服务节点的时候，需要调⽤注册中⼼提供的接⼝，添加节点信息或者删除节点。这个时候静态
    注册中⼼有点退化到配置中⼼的意思，只不过这个时候配置中⼼⾥存储的不是某⼀项配置，⽽是某个服务的可⽤节点信息。
       
       
    
**2. 服务消费者摘除机制**
    
       虽然注册中⼼主动摘除机制可以解决服务提供者节点异常的问题，但如果是因为注册中⼼与服务提供者之间的⽹络出现异常，最坏的情况是注册中⼼会把服务节
       点全部摘除，导致服务消费者没有可⽤的服务节点调⽤，但其实这时候服务提供者本身是正常的。所以，将存活探测机制⽤在服务消费者这⼀端更合理，如果
       服务消费者调⽤服务提供者节点失败，就将这个节点从内存中保存的可⽤服务提供者节点列表中移除
    
## 负载均衡 

### 随机算法

### 轮询算法

### 加权轮询算法

### 最少活跃连接算法

### ⼀致性hash算法

### ⾃适应最优选择算法

# 服务路由

    对于服务消费者⽽⾔，在内存中的可⽤服务节点列表中选择哪个节点不仅由负载均衡算法决定，还由路由规则确定。
    
    所谓的路由规则，就是服务消费者在发起服务调⽤时，必须根据特定的规则来选择服务节点，从⽽满⾜某些特定的需求。
    
    为什么要制定路由规则呢？主要有两个原因。
    
    1. 业务存在灰度发布的需求
    
       ⽐如，服务提供者做了功能变更，但希望先只让部分⼈群使⽤，然后根据这部分⼈群的使⽤反馈，再来决定是否做全量发布。这个时候，就可以通过类似按尾
       号进⾏灰度的规则限定只有⼀定⽐例的⼈群才会访问新发布的服务节点。
       
    2. 多机房就近访问的需求
    
       据我所知，⼤部分业务规模中等及以上的互联⽹公司，为了业务的⾼可⽤性，都会将⾃⼰的业务部署在不⽌⼀个IDC中。这个时候就存在⼀个问题，不同IDC之
       间的访问由于要跨IDC，通过专线访问，尤其是IDC相距⽐较远时延迟就会⽐较⼤，⽐如北京和⼴州的专线延迟⼀般在30ms左右，这对于某些延时敏感性的业务
       是不可接受的，所以就要⼀次服务调⽤尽量选择同⼀个IDC内部的节点，从⽽减少⽹络耗时开销，提⾼性能。这时⼀般可以通过IP段规则来控制访问，在选择
       服务节点时，优先选择同⼀IP段的节点。

# 服务路由的应⽤场景
  
   **分组调⽤:**
           
    ⼀般来讲，为了保证服务的⾼可⽤性，实现异地多活的需求，⼀个服务往往不⽌部署在⼀个数据中⼼，⽽且出于节省成本等考虑，有些业务可能不仅在私有机房
    部署，还会采⽤公有云部署，甚⾄采⽤多家公有云部署。服务节点也会按照不同的数据中⼼分成不同的分组，这时对于服务消费者来说，选择哪⼀个分组调⽤，就
    必须有相应的路由规则。

   **灰度发布:**
    
    在服务上线发布的过程中，⼀般需要先在⼀⼩部分规模的服务节点上先发布服务，然后验证功能是否正常。如果正常的话就继续扩⼤发布范围；如果不
    正常的话，就需要排查问题，解决问题后继续发布。这个过程就叫作灰度发布，也叫⾦丝雀部署。
    
   **流量切换**
    
    在业务线上运⾏过程中，经常会遇到⼀些不可抗⼒因素导致业务故障，⽐如某个机房的光缆被挖断，或者发⽣着⽕等事故导致整个机房的服务都不可⽤。
    这个时候就需要按照某个指令，能够把原来调⽤这个机房服务的流量切换到其他正常的机房。
    
   **读写分离**
    
    对于⼤多数互联⽹业务来说都是读多写少，所以在进⾏服务部署的时候，可以把读写分开部署，所有写接⼝可以部署在⼀起，⽽读接⼝部署在另外的节
    点上
    
    
# 服务路由的规则


# 服务路由配置⽅式  

**⼀般有两种配置⽅式。**


     1. 静态配置
     
        就是在服务消费者本地存放服务调⽤的路由规则，在服务调⽤期间，路由规则不会发⽣改变，要想改变就需要修改服务消费者本地配置，上线后才能⽣效。

     2. 动态配置
     
        这种⽅式下，路由规则是存在注册中⼼的，服务消费者定期去请求注册中⼼来保持同步，要想改变服务消费者的路由配置，可以通过修改注册中⼼的配置，服
        务消费者在下⼀个同步周期之后，就会请求注册中⼼来更新配置，从⽽实现动态更新。

# 服务容错

    服务调⽤并不总是⼀定成功的，前⾯我讲过，可能因为服务提供者节点⾃身宕机、进程异常退出或者服务消费者与提供者之间的⽹络出现故障等原因。对于服务调
    ⽤失败的情况，需要有⼿段⾃动恢复，来保证调⽤成功。
     
    FailOver：失败⾃动切换。就是服务消费者发现调⽤失败或者超时后，⾃动从可⽤的服务节点列表总选择下⼀个节点重新发起调⽤，也可以设置重试的次数。
     这种策略要求服务调⽤的操作必须是幂等的，也就是说⽆论调⽤多少次，只要是同⼀个调⽤，返回的结果都是相同的，⼀般适合服务调⽤是读请求的场景。
     
    FailBack：失败通知。就是服务消费者调⽤失败或者超时后，不再重试，⽽是根据失败的详细信息，来决定后续的执⾏策略。⽐如对于⾮幂等的调⽤场景，如果
    调⽤失败后，不能简单地重试，⽽是应该查询服务端的状态，看调⽤到底是否实际⽣效，如果已经⽣效了就不能再重试了；如果没有⽣效可以再发起⼀次调⽤。
    
    FailCache：失败缓存。就是服务消费者调⽤失败或者超时后，不⽴即发起重试，⽽是隔⼀段时间后再次尝试发起调⽤。⽐如后端服务可能⼀段时间内都有问题，
    如果⽴即发起重试，可能会加剧问题，反⽽不利于后端服务的恢复。如果隔⼀段时间待后端节点恢复后，再次发起调⽤效果会更好。
    
    FailFast：快速失败。就是服务消费者调⽤⼀次失败后，不再重试。实际在业务执⾏时，⼀般⾮核⼼业务的调⽤，会采⽤快速失败策略，调⽤失败后⼀般就记录下
    失败⽇志就返回了。
    
    
    
     
     
  
