
* [注册中⼼](#注册中⼼)
* [注册中⼼实现⽅式  ](#注册中⼼实现⽅式  )
* [注册与发现的⼏个问题](#注册与发现的⼏个问题)
* [注册中⼼选型考虑的几个问题](#注册中⼼如何选型)
  * [应⽤内注册与发现](#应⽤内注册与发现)
    * Eureka
    * Zookeeper
  * [应⽤外注册与发现](#应⽤外注册与发现)
    * Consul
  * [⾼可⽤性]()
  * [数据⼀致性]()

---

## 注册中⼼

    有了服务的接⼝描述，下⼀步要解决的问题就是服务的发布和订阅，就是说你提供了⼀个服务，如何让外部想调⽤你的服务的⼈知道。这个时候就需要⼀个类似
    注册中⼼的⻆⾊，服务提供者将⾃⼰提供的服务以及地址登记到注册中⼼，服务消费者则从注册中⼼查询所需要调⽤的服务的地址，然后发起请求。
    
    注册中⼼可以说是实现服务化的关键，因为服务化之后，服务提供者和服务消费者不在同⼀个进程中运⾏，实现了解耦，这就需要⼀个纽带去连接服务提供者和
    服务消费者，⽽注册中⼼就正好承担了这⼀⻆⾊。此外，服务提供者可以任意伸缩即增加节点或者减少节点，通过服务健康状态检测，注册中⼼可以保持最新的
    服务节点信息，并将变化通知给订阅服务的服务消费者
    
    注册中⼼原理

    在微服务架构下，主要有三种⻆⾊：服务提供者（RPC Server）、服务消费者（RPC Client）和服务注册中⼼（Registry），三者的交互关系请看下⾯这张图
    ，我来简单解释⼀下。
    
<a href="https://ibb.co/hHFB92C"><img src="https://i.ibb.co/5vhr4s2/05-17-12.png" alt="05-17-12" border="0"></a>    
    
    
    RPC Server提供服务，在启动时，根据服务发布⽂件server.xml中的配置的信息，向Registry注册⾃身服务，并向Registry定期发送⼼跳汇报存活状态。
    
    RPC Client调⽤服务，在启动时，根据服务引⽤⽂件client.xml中配置的信息，向Registry订阅服务，把Registry返回的服务节点列表缓存在本地内存中，并与
    RPC Sever建⽴连接。
    
    当RPC Server节点发⽣变更时，Registry会同步变更，RPC Client感知后会刷新本地内存中缓存的服务节点列表。
    
    RPC Client从本地缓存的服务节点列表中，基于负载均衡算法选择⼀台RPC Sever发起调⽤。
    
    
 ## 注册中⼼实现⽅式   

注册中⼼的实现主要涉及⼏个问题：[1. 注册中⼼需要提供哪些API接口]()，[2. 该如何部署]()；[3. 如何存储服务信息]()；[4. 如何监控服务提供者节点
的存活]()；[5. 如果服务提供者节点有变化如何通知服务消费者]()，[6. 以及如何控制注册中⼼的访问权限]()

### 1.  注册中⼼需要提供哪些API接口

    1. 服务注册接⼝：服务提供者通过调⽤服务注册接⼝来完成服务注册。
       
       ⾸先查看要注册的节点是否在⽩名单内？如果不在就抛出异常，在的话继续下⼀步。

       其次要查看注册的Cluster（服务的接⼝名）是否存在？如果不存在就抛出异常，存在的话继续下⼀步。
       
       然后要检查Service（服务的分组）是否存在？如果不存在则抛出异常，存在的话继续下⼀步。
       
       最后将节点信息添加到对应的Service和Cluster下⾯的存储中。
       
    2. 服务反注册接⼝：服务提供者通过调⽤服务反注册接⼝来完成服务注销。
    
       查看Service（服务的分组）是否存在，不存在就抛出异常，存在就继续下⼀步。
       
       查看Cluster（服务的接⼝名）是否存在，不存在就抛出异常，存在就继续下⼀步。
       
       删除存储中Service和Cluster下对应的节点信息。
       
       更新Cluster的sign值。
    
    3. ⼼跳汇报接⼝：服务提供者通过调⽤⼼跳汇报接⼝完成节点存活状态上报。
    4. 服务订阅接⼝：服务消费者通过调⽤服务订阅接⼝完成服务订阅，获取可⽤的服务提供者节点列表。
    5. 服务变更查询接⼝：服务消费者通过调⽤服务变更查询接⼝，获取最新的可⽤服务节点列表。
    
       服务消费者从注册中⼼获取了服务的信息后，就订阅了服务的变化，会在本地保留Cluster的sign值。
       
       服务消费者每隔⼀段时间，调⽤getSign()函数，从注册中⼼获取服务端该Cluster的sign值，并与本地保留的sign值做对⽐，如果不⼀致，就从服务端拉
       取新的节点信息，并更新localcache和snapshot。
       
    6. 服务查询接⼝：查询注册中⼼当前注册了哪些服务信息。
    
       ⾸先从localcache（本机内存）中查找，如果没有就继续下⼀步。这⾥为什么服务消费者要把服务信息存在本机内存呢？主要是因为服务节点信息并不总
       是时刻变化的，并不需要每⼀次服务调⽤都要调⽤注册中⼼获取最新的节点信息，只需要在本机内存中保留最新的服务提供者的节点列表就可以。
       
       接着从snapshot（本地快照）中查找，如果没有就继续下⼀步。这⾥为什么服务消费者要在本地磁盘存储⼀份服务提供者的节点信息的快照呢？这是因为服务
       消费者同注册中⼼之间的⽹络不⼀定总是可靠的，服务消费者重启时，本机内存中还不存在服务提供者的节点信息，如果此时调⽤注册中⼼失败，那么服务消
       费者就拿不到服务节点信息了，也就没法调⽤了。本地快照就是为了防⽌这种情况的发⽣，即使服务消费者重启后请求注册中⼼失败，依然可以读取本地快照，
       获取到服务节点信息
       
    7. 服务修改接⼝：修改注册中⼼中某⼀服务的信息。

### 2. 如何部署:
    
    集群部署

    注册中⼼⼀般都是采⽤集群部署来保证⾼可⽤性，并通过分布式⼀致性协议来确保集群中不同节点之间的数据保持⼀致.
    
### 3. 如何存储服务信息    

     ⽬录存储: 注册中⼼存储服务信息⼀般采⽤层次化的⽬录结构
     
     所以注册中⼼存储的服务信息⼀般包含三部分内容：分组、服务名以及节点信息，节点信息⼜包括节点地址和节点其他信息
     
### 4. 如何监控服务提供者节点的存活     

    服务健康状态检测
    
    注册中⼼除了要⽀持最基本的服务注册和服务订阅功能以外，还必须具备对服务提供者节点的健康状态检测功能，这样才能保证注册中⼼⾥保存的服务节点都是
    可⽤的
    
    
###  5. 如果服务提供者节点有变化如何通知服务消费者

    服务状态变更通知
    
    ⼀旦注册中⼼探测到有服务提供者节点新加⼊或者被剔除，就必须⽴刻通知所有订阅该服务的服务消费者，刷新本地缓存的服务节点信息，确保服务调⽤不会请
    求不可⽤的服务提供者节点。

### 6. 以及如何控制注册中⼼的访问权限 
    
    ⽩名单机制
    
    在实际的微服务测试和部署时，通常包含多套环境，⽐如⽣产环境⼀套、测试环境⼀套。开发在进⾏业务⾃测、测试在进⾏回归测试时，⼀般都是⽤测试环境，
    部署的RPC Server节点注册到测试的注册中⼼集群。但经常会出现开发或者测试在部署时，错误的把测试环境下的服务节点注册到了线上注册中⼼集群，这样
    的话线上流量就会调⽤到测试环境下的RPC Server节点，可能会造成意想不到的后果。为了防⽌这种情况发⽣，注册中⼼需要提供⼀个保护机制，你可以把注
    册中⼼想象成⼀个带有⻔禁的房间，只有拥有⻔禁卡的RPC Server才能进⼊。在实际应⽤中，注册中⼼可以提供⼀个⽩名单机制，只有添加到注册中⼼⽩名单
    内的RPC Server，才能够调⽤注册中⼼的注册接⼝，这样的话可以避免测试环境中的节点意外跑到线上环境中去
     
## 注册与发现的⼏个问题


### 1. 多注册中⼼

      理论上对于⼀个服务消费者来说，同⼀个注册中⼼交互是最简单的。但是不可避免的是，服务消费者可能订阅了多个服务，多个服务可能是由多个业务部⻔
      提供的，⽽且每个业务部⻔都有⾃⼰的注册中⼼，提供的服务只在⾃⼰的注册中⼼⾥有记录。这样的话，就要求服务消费者要具备在启动时，能够从多个注册
      中⼼订阅服务的能⼒。根据我的经验，还有⼀种情况是，⼀个服务提供者提供了某个服务，可能作为静态服务对外提供，有可能⼜作为动态服务对外提供，这
      两个服务部署在不同的注册中⼼，所以要求服务提供者在启动的时候，要能够同时向多个注册中⼼注册服务。也就是说，对于服务消费者来说，要能够同时从
      多个注册中⼼订阅服务；对于服务提供者来说，要能够同时向多个注册中⼼注册服务。
      
### 2. 并⾏订阅服务

      通常⼀个服务消费者订阅了不⽌⼀个服务，在我经历的⼀个项⽬中，⼀个服务消费者订阅了⼏⼗个不同的服务，每个服务都有⾃⼰的⽅法列表以及节点列表。
      服务消费者在服务启动时，会加载订阅的服务配置，调⽤注册中⼼的订阅接⼝，获取每个服务的节点列表并初始化连接。最开始我们采⽤了串⾏订阅的⽅式，
      每订阅⼀个服务，服务消费者调⽤⼀次注册中⼼的订阅接⼝，获取这个服务的节点列表并初始化连接，总共需要执⾏⼏⼗次这样的过程。在某些服务节点的初
      始化连接过程中，出现连接超时的情况，后续所有的服务节点的初始化连接都需要等待它完成，导致服务消费者启动变慢，最后耗费了将近五分钟时间来完成
      所有服务节点的初始化连接过程。后来我们改成了并⾏订阅的⽅式，每订阅⼀个服务就单独⽤⼀个线程来处理，这样的话即使遇到个别服务节点连接超时，其
      他服务节点的初始化连接也不受影响，最慢也就是这个服务节点的初始化连接耗费的时间，最终所有服务节点的初始化连接耗时控制在了30秒以内      
      
### 3. 批量反注册服务

      通常⼀个服务提供者节点提供不⽌⼀个服务，所以注册和反注册都需要多次调⽤注册中⼼。在与注册中⼼的多次交互中，可能由于⽹络抖动、注册中⼼集群异常
      等原因，导致个别调⽤失败。对于注册中⼼来说，偶发的注册调⽤失败对服务调⽤基本没有影响，其结果顶多就是某⼀个服务少了⼀个可⽤的节点。但偶发的反
      注册调⽤失败会导致不可⽤的节点残留在注册中⼼中，变成“僵⼫节点”，但服务消费者端还会把它当成“活节点”，继续发起调⽤，最终导致调⽤失败。以前我们
      的业务中经常遇到这个问题，需要定时去清理注册中⼼中的“僵⼫节点”。后来我们通过优化反注册逻辑，对于下线机器、节点销毁的场景，通过调⽤注册中⼼提
      供的批量反注册接⼝，⼀次调⽤就可以把该节点上提供的所有服务同时反注册掉，从⽽避免了“僵⼫节点”的出现。 
      
### 4. 服务变更信息增量更新
    
      服务消费者端启动时，除了会查询订阅服务的可⽤节点列表做初始化连接，还会订阅服务的变更，每隔⼀段时间从注册中⼼获取最新的服务节点信息标记sign，
      并与本地保存的sign值作⽐对，如果不⼀样，就会调⽤注册中⼼获取最新的服务节点信息。⼀般情况下，按照这个过程是没问题的，但是在⽹络频繁抖动时，服
      务提供者上报给注册中⼼的⼼跳可能会⼀会⼉失败⼀会⼉成功，这时候注册中⼼就会频繁更新服务的可⽤节点信息，导致服务消费者频繁从注册中⼼拉取最新的
      服务可⽤节点信息，严重时可能产⽣⽹络⻛暴，导致注册中⼼带宽被打满。为了减少服务消费者从注册中⼼中拉取的服务可⽤节点信息的数据量，这个时候可以
      通过增量更新的⽅式，注册中⼼只返回变化的那部分节点信息，尤其在只有少数节点信息变更时，此举可以⼤⼤减少服务消费者从注册中⼼拉取的数据量，从⽽
      最⼤程度避免产⽣⽹络⻛暴。      
      
## 注册中⼼如何选型

    当下主流的服务注册与发现的解决⽅案，主要有两种：
    
    应⽤内注册与发现：注册中⼼提供服务端和客户端的SDK，业务应⽤通过引⼊注册中⼼提供的SDK，通过SDK与注册中⼼交互，来实现服务的注册和发现。

    应⽤外注册与发现：业务应⽤本身不需要通过SDK与注册中⼼打交道，⽽是通过其他⽅式与注册中⼼交互，间接完成服务注册与发现。
    
    这两种解决⽅案的不同之处在于应⽤场景，应⽤内的解决⽅案⼀般适⽤于服务提供者和服务消费者同属于⼀个技术体系；应⽤外的解决⽅案⼀般适合服务提供者
    和服务消费者采⽤了不同技术体系的业务场景，⽐如服务提供者提供的是C++服务，⽽服务消费者是⼀个Java应⽤，这时候采⽤应⽤外的解决⽅案就不依赖于具
    体⼀个技术体系。同时，对于容器化后的云应⽤来说，⼀般不适合采⽤应⽤内SDK的解决⽅案，因为这样会侵⼊业务，⽽应⽤外的解决⽅案正好能够解决这个问题

    如果你的业务体系都采⽤Java语⾔的话，Netflix开源的Eureka是⼀个不错的选择，并且它作为服务注册与发现解决⽅案，能够最⼤程度的保证可⽤性，即使出现
    了⽹络问题导致不同节点间数据不⼀致，你仍然能够访问Eureka获取数据。
    
    如果你的业务体系语⾔⽐较复杂，Eureka也提供了Sidecar的解决⽅案；也可以考虑使⽤Consul，它⽀持了多种语⾔接⼊，包括Go、Python、PHP、Scala、
    Java，Erlang、Ruby、Node.js、.NET、Perl等。

    如果你的业务已经是云原⽣的应⽤，可以考虑使⽤Consul，搭配Registrator和Consul Template来实现应⽤外的服务注册与发现。

###  应⽤内注册与发现
#### Eureka
### 应⽤外注册与发现
#### Consul
